"use strict";(self.webpackChunkfilebridge_docs=self.webpackChunkfilebridge_docs||[]).push([[922],{7999(e,n,r){r.r(n),r.d(n,{assets:()=>c,contentTitle:()=>d,default:()=>h,frontMatter:()=>l,metadata:()=>i,toc:()=>o});const i=JSON.parse('{"id":"Transfer-Engine","title":"Transfer Engine","description":"The transfer engine (lib/transfer/engine.ts) is the core of FileBridge. It orchestrates every file-level operation for a job run: listing files, applying filters, downloading, extracting, uploading, post-transfer actions, and recording audit logs.","source":"@site/../docs/Transfer-Engine.md","sourceDirName":".","slug":"/Transfer-Engine","permalink":"/FileBridge/docs/Transfer-Engine","draft":false,"unlisted":false,"tags":[],"version":"current","frontMatter":{},"sidebar":"docsSidebar","previous":{"title":"Jobs","permalink":"/FileBridge/docs/Jobs"},"next":{"title":"Database Backups","permalink":"/FileBridge/docs/Database-Backups"}}');var s=r(4848),t=r(8453);const l={},d="Transfer Engine",c={},o=[{value:"Execution Flow",id:"execution-flow",level:2},{value:"File Listing and Filtering",id:"file-listing-and-filtering",level:2},{value:"Overwrite Behavior",id:"overwrite-behavior",level:2},{value:"Archive Extraction",id:"archive-extraction",level:2},{value:"Limitation: Delta Sync + Archive Extraction",id:"limitation-delta-sync--archive-extraction",level:3},{value:"Delta Sync",id:"delta-sync",level:2},{value:"Post-Transfer Actions",id:"post-transfer-actions",level:2},{value:"Progress Tracking",id:"progress-tracking",level:2},{value:"Dry Run",id:"dry-run",level:2},{value:"DryRunResult Structure",id:"dryrunresult-structure",level:3},{value:"DryRunFile Structure",id:"dryrunfile-structure",level:3},{value:"Error Handling",id:"error-handling",level:2}];function a(e){const n={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",hr:"hr",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",table:"table",tbody:"tbody",td:"td",th:"th",thead:"thead",tr:"tr",ul:"ul",...(0,t.R)(),...e.components};return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.header,{children:(0,s.jsx)(n.h1,{id:"transfer-engine",children:"Transfer Engine"})}),"\n",(0,s.jsxs)(n.p,{children:["The transfer engine (",(0,s.jsx)(n.code,{children:"lib/transfer/engine.ts"}),") is the core of FileBridge. It orchestrates every file-level operation for a job run: listing files, applying filters, downloading, extracting, uploading, post-transfer actions, and recording audit logs."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"execution-flow",children:"Execution Flow"}),"\n",(0,s.jsx)(n.p,{children:"When a job is triggered (scheduled or manual), the engine executes these steps in order:"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:'1. Load job from database\n2. Check concurrent run guard (skip if already running)\n3. Save pre-run status (active / inactive) for post-run restoration\n4. Load source and destination connection configs\n5. Insert job_runs record with status = "running"\n6. Mark job status = "running" in jobs table\n7. Connect to source storage provider\n8. Connect to destination storage provider\n9. List source files (with glob filter applied by the provider)\n10. Filter out hidden files (if skipHiddenFiles = true)\n11. Filter out the move subfolder (if post-action = "move" and movePath \u2282 sourcePath)\n12. Update job_runs.totalFiles\n13. (Optional) List destination files for overwrite-check / delta-sync\n14. For each source file:\n    a. Update job_runs.currentFile\n    b. Delta sync check \u2192 skip if destination is same age or newer\n    c. Overwrite check \u2192 skip if exists and overwrite = false\n    d. Download file from source (streamed \u2014 not buffered in memory)\n    e. If extractArchives \u2192 buffer and extract archive, upload each entry individually\n    f. Else \u2192 stream directly to destination (delete existing first if overwrite/delta)\n    g. Apply post-transfer action (retain / delete / move)\n    h. Insert transfer_logs record (success or failure)\n    i. Increment filesTransferred + bytesTransferred counters\n15. Disconnect both providers\n16. Update job_runs: status = "success", final counts, completedAt\n17. Restore job status (active or inactive \u2014 not "error")\n'})}),"\n",(0,s.jsxs)(n.p,{children:["If any uncaught error occurs during steps 7\u201317, the engine catches it, updates ",(0,s.jsx)(n.code,{children:"job_runs"})," to ",(0,s.jsx)(n.code,{children:"failure"}),", sets ",(0,s.jsx)(n.code,{children:"jobs.status"})," to ",(0,s.jsx)(n.code,{children:"error"})," (or ",(0,s.jsx)(n.code,{children:"inactive"})," if it was inactive before), and re-throws."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"file-listing-and-filtering",children:"File Listing and Filtering"}),"\n",(0,s.jsxs)(n.p,{children:["The engine calls ",(0,s.jsx)(n.code,{children:"source.listFiles(sourcePath, fileFilter)"}),". Each storage provider applies the glob filter internally using ",(0,s.jsx)(n.code,{children:"globToRegex()"})," from ",(0,s.jsx)(n.code,{children:"lib/storage/interface.ts"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The glob filter supports:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"*"})," \u2014 matches any sequence of characters"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"?"})," \u2014 matches exactly one character"]}),"\n",(0,s.jsxs)(n.li,{children:["Multiple patterns separated by commas: ",(0,s.jsx)(n.code,{children:"*.csv, *.txt"})]}),"\n",(0,s.jsx)(n.li,{children:"Case-insensitive matching"}),"\n",(0,s.jsx)(n.li,{children:"Empty string = match all files"}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:[(0,s.jsx)(n.strong,{children:"Hidden file filtering"})," is a separate layer applied after the provider returns its list. Any file whose name starts with ",(0,s.jsx)(n.code,{children:"."})," is excluded when ",(0,s.jsx)(n.code,{children:"skipHiddenFiles = true"}),"."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"overwrite-behavior",children:"Overwrite Behavior"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:(0,s.jsx)(n.code,{children:"overwriteExisting"})}),(0,s.jsx)(n.th,{children:(0,s.jsx)(n.code,{children:"deltaSync"})}),(0,s.jsx)(n.th,{children:"File exists at dest"}),(0,s.jsx)(n.th,{children:"Behavior"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"false"}),(0,s.jsx)(n.td,{children:"false"}),(0,s.jsx)(n.td,{children:"No"}),(0,s.jsx)(n.td,{children:"Transfer the file"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"false"}),(0,s.jsx)(n.td,{children:"false"}),(0,s.jsx)(n.td,{children:"Yes"}),(0,s.jsx)(n.td,{children:"Skip (logged, not transferred)"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"true"}),(0,s.jsx)(n.td,{children:"false"}),(0,s.jsx)(n.td,{children:"No"}),(0,s.jsx)(n.td,{children:"Transfer the file"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"true"}),(0,s.jsx)(n.td,{children:"false"}),(0,s.jsx)(n.td,{children:"Yes"}),(0,s.jsx)(n.td,{children:"Delete dest file, then upload"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"false"}),(0,s.jsx)(n.td,{children:"true"}),(0,s.jsx)(n.td,{children:"No"}),(0,s.jsx)(n.td,{children:"Transfer the file"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"false"}),(0,s.jsx)(n.td,{children:"true"}),(0,s.jsx)(n.td,{children:"Yes, dest is newer"}),(0,s.jsx)(n.td,{children:"Skip"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:"false"}),(0,s.jsx)(n.td,{children:"true"}),(0,s.jsx)(n.td,{children:"Yes, source is newer"}),(0,s.jsx)(n.td,{children:"Delete dest file, then upload"})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["Delta sync implicitly enables overwrite for files that pass the timestamp check. The destination file is deleted before uploading to avoid SMB ",(0,s.jsx)(n.code,{children:"STATUS_OBJECT_NAME_COLLISION"})," errors."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"archive-extraction",children:"Archive Extraction"}),"\n",(0,s.jsxs)(n.p,{children:["When ",(0,s.jsx)(n.code,{children:"extractArchives = true"})," and a file is recognized as an archive:"]}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsx)(n.li,{children:"The archive is downloaded from the source and buffered in memory (archives cannot be streamed because ZIP requires random access and TAR requires sequential parsing of the full file)"}),"\n",(0,s.jsx)(n.li,{children:"The engine extracts all file entries (directories are skipped)"}),"\n",(0,s.jsxs)(n.li,{children:["Nested paths within the archive are ",(0,s.jsx)(n.strong,{children:"flattened"})," \u2014 files land directly in ",(0,s.jsx)(n.code,{children:"destinationPath"})]}),"\n",(0,s.jsx)(n.li,{children:"Each extracted entry is uploaded individually"}),"\n",(0,s.jsxs)(n.li,{children:["A ",(0,s.jsx)(n.code,{children:"transfer_logs"})," entry is written for each extracted entry, using a virtual source path ",(0,s.jsx)(n.code,{children:"archive.zip!entry.csv"})]}),"\n",(0,s.jsxs)(n.li,{children:["The original archive file is ",(0,s.jsx)(n.strong,{children:"not"})," uploaded to the destination"]}),"\n",(0,s.jsxs)(n.li,{children:["The post-transfer action (retain/delete/move) is applied to the ",(0,s.jsx)(n.strong,{children:"original archive"})," on the source"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"Supported formats:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:".zip"})," \u2014 via ",(0,s.jsx)(n.code,{children:"yauzl"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:".tar"})," \u2014 via ",(0,s.jsx)(n.code,{children:"tar-stream"})]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:".tar.gz"})," and ",(0,s.jsx)(n.code,{children:".tgz"})," \u2014 via ",(0,s.jsx)(n.code,{children:"tar-stream"})," + Node.js built-in ",(0,s.jsx)(n.code,{children:"zlib.gunzipSync"})]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"If extraction returns no entries (empty archive), the engine falls through and transfers the archive as-is."}),"\n",(0,s.jsx)(n.h3,{id:"limitation-delta-sync--archive-extraction",children:"Limitation: Delta Sync + Archive Extraction"}),"\n",(0,s.jsx)(n.p,{children:"These two features are incompatible. When both are enabled:"}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:"Delta sync is silently ignored for archive files"}),"\n",(0,s.jsx)(n.li,{children:"All archives are downloaded and extracted on every run"}),"\n",(0,s.jsx)(n.li,{children:"This is because the source listing only shows the archive filename; individual entry timestamps can't be checked without downloading and unpacking first"}),"\n"]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"delta-sync",children:"Delta Sync"}),"\n",(0,s.jsxs)(n.p,{children:["Delta sync compares ",(0,s.jsx)(n.code,{children:"modifiedAt"})," timestamps between source and destination files."]}),"\n",(0,s.jsxs)(n.p,{children:["The destination is listed once before the per-file loop and cached in a ",(0,s.jsx)(n.code,{children:"Map<string, Date>"}),". This avoids one network round-trip per file."]}),"\n",(0,s.jsx)(n.p,{children:"Decision logic (per file):"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{children:"if deltaSync && file exists at dest:\n    if destModifiedAt >= srcModifiedAt \u2192 skip (destination is up to date)\n    else \u2192 transfer (source is newer)\nelse if !overwriteExisting && file exists at dest:\n    skip\nelse:\n    transfer\n"})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"post-transfer-actions",children:"Post-Transfer Actions"}),"\n",(0,s.jsx)(n.p,{children:"Applied after a successful upload (or archive extraction):"}),"\n",(0,s.jsxs)(n.table,{children:[(0,s.jsx)(n.thead,{children:(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.th,{children:"Action"}),(0,s.jsx)(n.th,{children:"What happens"})]})}),(0,s.jsxs)(n.tbody,{children:[(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"retain"})}),(0,s.jsx)(n.td,{children:"Nothing \u2014 the source file is left in place"})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"delete"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:"source.deleteFile(srcPath)"})," is called"]})]}),(0,s.jsxs)(n.tr,{children:[(0,s.jsx)(n.td,{children:(0,s.jsx)(n.code,{children:"move"})}),(0,s.jsxs)(n.td,{children:[(0,s.jsx)(n.code,{children:'source.moveFile(srcPath, movePath + "/" + filename)'})," is called"]})]})]})]}),"\n",(0,s.jsxs)(n.p,{children:["Post-transfer action failures are caught and logged but do ",(0,s.jsx)(n.strong,{children:"not"})," fail the overall file transfer \u2014 the ",(0,s.jsx)(n.code,{children:"transfer_logs"})," entry is still recorded as ",(0,s.jsx)(n.code,{children:"success"}),"."]}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"progress-tracking",children:"Progress Tracking"}),"\n",(0,s.jsxs)(n.p,{children:["The engine updates ",(0,s.jsx)(n.code,{children:"job_runs"})," records in real time so the UI can show progress:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"job_runs.totalFiles"})," \u2014 set once after listing (before the per-file loop)"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"job_runs.currentFile"})," \u2014 updated before each file starts downloading"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"job_runs.filesTransferred"})," and ",(0,s.jsx)(n.code,{children:"job_runs.bytesTransferred"})," \u2014 incremented after each successful upload"]}),"\n",(0,s.jsxs)(n.li,{children:[(0,s.jsx)(n.code,{children:"job_runs.currentFile"})," \u2014 set to ",(0,s.jsx)(n.code,{children:"null"})," when the run completes or fails"]}),"\n"]}),"\n",(0,s.jsx)(n.p,{children:"The Jobs page auto-refreshes every 10 seconds to surface these updates."}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"dry-run",children:"Dry Run"}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"dryRunJob(jobId)"})," function performs all the same logic as ",(0,s.jsx)(n.code,{children:"runJob"})," except:"]}),"\n",(0,s.jsxs)(n.ul,{children:["\n",(0,s.jsx)(n.li,{children:(0,s.jsx)(n.strong,{children:"No files are transferred, deleted, or moved"})}),"\n",(0,s.jsx)(n.li,{children:"Both source and destination are connected read-only (list operations only)"}),"\n",(0,s.jsxs)(n.li,{children:["Returns a ",(0,s.jsx)(n.code,{children:"DryRunResult"})," object describing what would happen"]}),"\n"]}),"\n",(0,s.jsx)(n.h3,{id:"dryrunresult-structure",children:"DryRunResult Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:"{\n  jobId: number;\n  jobName: string;\n  sourcePath: string;\n  destinationPath: string;\n  fileFilter: string;\n  files: DryRunFile[];        // One entry per source file\n  totalInSource: number;      // All files visible in source dir\n  totalMatched: number;       // Files matching the filter\n  wouldTransfer: number;      // Files that would be uploaded\n  wouldSkip: number;          // Files that would be skipped (all reasons)\n  skippedByFilter: number;    // Skipped because they don't match the filter\n  skippedByExists: number;    // Skipped because they exist and overwrite is off\n  skippedByDelta: number;     // Skipped because destination is same age or newer\n  totalBytes: number;         // Bytes that would be transferred\n}\n"})}),"\n",(0,s.jsx)(n.h3,{id:"dryrunfile-structure",children:"DryRunFile Structure"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-ts",children:'{\n  name: string;\n  size: number;\n  modifiedAt: string;         // ISO timestamp\n  wouldSkip: boolean;\n  skipReason: "filter" | "exists" | "delta" | null;\n  postAction: "retain" | "delete" | "move";\n  moveDest: string | null;    // Full path if postAction = "move"\n  isArchive: boolean;\n  wouldExtract: boolean;      // true if extractArchives + isArchive\n}\n'})}),"\n",(0,s.jsx)(n.hr,{}),"\n",(0,s.jsx)(n.h2,{id:"error-handling",children:"Error Handling"}),"\n",(0,s.jsx)(n.p,{children:"Per-file errors are caught individually. A failed file is:"}),"\n",(0,s.jsxs)(n.ol,{children:["\n",(0,s.jsxs)(n.li,{children:["Recorded in ",(0,s.jsx)(n.code,{children:"transfer_logs"})," with ",(0,s.jsx)(n.code,{children:'status = "failure"'})," and the error message"]}),"\n",(0,s.jsxs)(n.li,{children:["Counted as skipped (not in ",(0,s.jsx)(n.code,{children:"filesTransferred"}),")"]}),"\n",(0,s.jsxs)(n.li,{children:["Does ",(0,s.jsx)(n.strong,{children:"not"})," abort the rest of the run \u2014 other files continue processing"]}),"\n"]}),"\n",(0,s.jsxs)(n.p,{children:["A connection-level error (e.g. can't connect to source) aborts the entire run and marks the ",(0,s.jsx)(n.code,{children:"job_runs"})," record as ",(0,s.jsx)(n.code,{children:"failure"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"Directory entries that slip through the listing filter (e.g. when a storage provider returns mixed files and directories) are detected by error message pattern and silently skipped."})]})}function h(e={}){const{wrapper:n}={...(0,t.R)(),...e.components};return n?(0,s.jsx)(n,{...e,children:(0,s.jsx)(a,{...e})}):a(e)}},8453(e,n,r){r.d(n,{R:()=>l,x:()=>d});var i=r(6540);const s={},t=i.createContext(s);function l(e){const n=i.useContext(t);return i.useMemo(function(){return"function"==typeof e?e(n):{...n,...e}},[n,e])}function d(e){let n;return n=e.disableParentContext?"function"==typeof e.components?e.components(s):e.components||s:l(e.components),i.createElement(t.Provider,{value:n},e.children)}}}]);